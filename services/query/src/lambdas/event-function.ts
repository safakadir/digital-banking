import { SQSEvent } from 'aws-lambda';
import { createQueryService } from '../services';
import { createDefaultTelemetryBundle } from '@digital-banking/utils';
import { BankingEvent } from '@digital-banking/events';
import { depositEventHandler } from './event-handlers/deposit-event-handler';
import { withdrawSuccessEventHandler } from './event-handlers/withdraw-success-event-handler';
import { withdrawFailedEventHandler } from './event-handlers/withdraw-failed-event-handler';
import { createAccountEventHandler } from './event-handlers/create-account-event-handler';
import { closeAccountEventHandler } from './event-handlers/close-account-event-handler';
import { commonEventMiddleware } from '@digital-banking/middleware';
import { IdempotencyConfig, makeIdempotent } from '@aws-lambda-powertools/idempotency';
import { DynamoDBPersistenceLayer } from '@aws-lambda-powertools/idempotency/dynamodb';

// Configure idempotency
const persistenceStore = new DynamoDBPersistenceLayer({
  tableName: process.env.IDEMPOTENCY_TABLE || 'QuerySvc-EventFn-Idempotency-dev',
});

const idempotencyConfig = new IdempotencyConfig({
  // Use message ID as the idempotency key (extracting from various message formats)
  eventKeyJmesPath: `
    Records[*].body | 
    fromjson(@).Type == 'Notification' ? 
      (fromjson(fromjson(@).Message).id ? 
        fromjson(fromjson(@).Message).id : 
        fromjson(fromjson(@).Message).eventData.id) : 
      fromjson(@).id
  `,
  // TTL for idempotency records (24 hours)
  expiresAfterSeconds: 86400,
});

/**
 * Creates an event handler with dependency injection support
 * @param queryService - QueryService instance
 * @param logger - Logger instance
 * @param tracer - Tracer instance
 * @param metrics - Metrics instance
 * @returns Event handler function
 */
export function createEventFunctionHandler(
  queryService = createQueryService(),
  telemetry = createDefaultTelemetryBundle()
) {
  const { logger } = telemetry;
  /**
   * Processes events for the Query service
   * Returns batchItemFailures for failed records to enable partial batch processing
   */

  const eventHandler = async (event: SQSEvent): Promise<{ batchItemFailures: { itemIdentifier: string }[] }> => {
    logger.info('Processing query events', { recordCount: event.Records.length });
    
    const batchItemFailures: { itemIdentifier: string }[] = [];
    
    for (const record of event.Records) {
      try {
        // Check if this is an SNS message wrapped in SQS
        const body = JSON.parse(record.body);
        
        // Handle SNS messages wrapped in SQS
        let message: BankingEvent;
        let messageId: string;
        
        if (body.Type === 'Notification') {
          // SNS message format from EventBridge Pipes
          const messageBody = JSON.parse(body.Message);
          
          // Check if this is from outbox table via EventBridge Pipes
          if (messageBody.eventData && messageBody.eventType) {
            // Extract the event data from the outbox format
            message = messageBody.eventData as BankingEvent;
            messageId = messageBody.id; // This is the UUID generated by EventPublisher
          } else {
            // Regular SNS message format (for backwards compatibility)
            message = messageBody as BankingEvent;
            messageId = message.id;
          }
        } else {
          // Direct SQS message format (for backwards compatibility)
          message = body as BankingEvent;
          messageId = message.id;
        }
        
        logger.info('Processing event', { 
          sqsMessageId: record.messageId, 
          eventType: message.type, 
          messageId: messageId 
        });
        
        switch (message.type) {
          case 'DEPOSIT_EVENT':
            await depositEventHandler(queryService, telemetry)(message);
            break;
          case 'WITHDRAW_SUCCESS_EVENT':
            await withdrawSuccessEventHandler(queryService, telemetry)(message);
            break;
          case 'WITHDRAW_FAILED_EVENT':
            await withdrawFailedEventHandler(queryService, telemetry)(message);
            break;
          case 'CREATE_ACCOUNT_EVENT':
            await createAccountEventHandler(queryService, telemetry)(message);
            break;
          case 'CLOSE_ACCOUNT_EVENT':
            await closeAccountEventHandler(queryService, telemetry)(message);
            break;
          default:
            // Exhaustive check to ensure all event types are handled
            const _exhaustiveCheck: never = message;
            logger.warn('Unknown event type', { eventType: (message as any).type });
        }
      } catch (error) {
        logger.error('Error processing record', { error, messageId: record.messageId });
        throw error;
      }
    }
    
    return { batchItemFailures };
  };
  
  // Make the handler idempotent
  const idempotentHandler = makeIdempotent(eventHandler, {
    persistenceStore,
    config: idempotencyConfig
  });
  
  // Return the handler with middleware
  return commonEventMiddleware(idempotentHandler, telemetry);
}

// Export the default handler instance
export const eventFunctionHandler = createEventFunctionHandler();